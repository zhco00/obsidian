## 객체 
1. 원시 값을 제외 한 모든 값
2. 변경 가능한 값
3. 프로퍼티와 메서드로 구성되어 있음
ex) const abc = {
name : 'Lee',
sayHi(){
console.log('HI! ' + this.name)
}
}

프로퍼티 - 키와 값으로 이루어져 있음.
프로퍼티 접근법 
1. 마침표 표기법 -> person.name
2. 대괄호 표기법 -> person['name']
ES6에선 프로퍼티 축약이 가능하다.
```
var abc= {
x : x,
y : y
}

var abc= {
x, y
}
```
 이렇게 표현 가능.

# 원시값과 객체의 차이
1. 원시 값은 값을 저장하면 변수에 실제 값이 저장 되지만 
   객체에는 실제 값이 저장된 주소가 저장됨. (한번 더 거쳐서 간다고 생각하면 될듯)
2. 원사값은 변경 불가능한 값이다. 하지만 var 또는 let에서는 재할당이 가능하다. 
   이유는 해당 값을 바꿔서 보여주는게 아닌 할당할 새로운 값을 다른 주소에 만들고 변수가 원래 값이아닌
   새로운 값을 만든 다른 주소를 가리키게 변경시키는 것이다. 그래서 변경은 불가능 하지만 재할당은 가능하다.
   const는 재할당도 안됨.

# 자바 스크립트의 객체 관리 방식
- 자바스크립트는 클래스 없이 객체 생성 가능하고, 동적으로 프로퍼티와 메서드를 추가할 수 있다.
- 다만 해당방식은 비효율적인 방식이기 때문에 히든 클래스라는 방식을 사용한다. 

얕은 복사 - 변수안에 객체가 저장되어 있을 경우 그걸 복사했을 때는 메모리 주소는 달라도 동일한 참조 값을 갖게 됨.
깊은 복사 -  복사는 하지만 같은 참조 값을 갖지 못하게 만들어 값만 같고 주소와 참조 값이 다름.


## 함수 사용 이유
1. 코드 재사용
2. 유지보수의 편의성
3. 코드의 신뢰성 향상
4. 코드의 가독성 향상

### 함수 정의 방식
1. 함수 선언문 --> function add(x, y){ return x+y}
2. 함수 표현식 --> var add = function (x, y) {return x+y}
3. 생성자 함수 --> var add = new Funtion('x', 'y', 'return x+y')
4. 화살표 함수 --> var add=(x, y)=> x+y

함수는 일급객체이므로 값으로 쓸 수 있다.
이경우 함수를 값 형태로 넣어줄 때 ==함수 표현식== 이라하고, 
값 형태가 아닌 그냥 함수 그 자체로 쓸 때는 ==함수 선언문== 이라한다.

## 일급객체

1. 무명의 리터럴로 생성할 수 있다.
2. 변수나 자료구조(객체, 배열)에 저장할 수 있다.
3. 함수의 매개 변수에 전달 할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

ft. 원시타입을 제외한 모든게 객체라는 뜻은 아니며, 객체로 취급할 수 있다가 맞음.

일급 객체(함수) == 객체 TRUE
일급 객체(함수) === 객체 FALSE

콜백함수 
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 한다. 
매개 변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수라고 한다.

## 스코프
모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
이를 스코프라 한다. 즉 스코프는 식별자가 유효한 범위를 뜻 한다.

전역 스코프
지역 스코프
스코프 체인

자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의 했는지에 따라 
상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 아무런 영향을 주지 않는다. 
즉 함수 의 상위 스코프는 언제나 자신이 정의된 스코프이다.